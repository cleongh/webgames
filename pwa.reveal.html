<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Progressive Web Apps</title>
<meta name="author" content="Carlos León"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="node_modules/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="node_modules/reveal.js/dist/theme/black.css" id="theme"/>

<link rel="stylesheet" href="base.css"/>
<link rel="stylesheet" href="node_modules/reveal.js/plugin/highlight/zenburn.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Progressive Web Apps</h1><h2 class="author">Carlos León</h2><h2 class="email"><a href="mailto:cleon@ucm.es">cleon@ucm.es</a></h2>
</section>
<section>
<section id="slide-qué-es-una-pwa">
<h2 id="qué-es-una-pwa">Qué es una PWA</h2>
</section>
<section>

<p>
Son aplicaciones web (HTML, JS, CSS), pero con ciertas cosas especiales
que permiten:
</p>

<ul>
<li>Funcionar sin conexión</li>
<li>Usar notificaciones nativas</li>
<li>Acceder al hardware del dispositivo</li>
<li>Instalarse fácilmente</li>
<li>Almacenamiento local</li>

</ul>

</section>
<section>

<p>
Aunque sean, técnicamente, una página web, reemplazan a las aplicaciones
nativas
</p>

<p>
Además, <i>el mismo código nos vale para una aplicación en escritorio,
móvil y web</i>
</p>
</section>
<section id="slide-por-qué-progressive">
<h3 id="por-qué-progressive">¿Por qué "progressive"?</h3>
<p>
Son "progresivas" porque se diseñan con la estrategia de "mejorado
progresivo"
</p>

</section>
<section>

<p>
El mejorado progresive consiste en diseñar un núcleo básico fundamental
(contenido y estructura básica), e ir añadiendo capas de funcionalidad
sobre ese núcleo
</p>

</section>
<section>

<p>
Por ejemplo, una PWA bien hecha funcionará sin conexión en navegadores
nuevos, y sin conexión en los viejos, pero aún así <i>podrá verse su
contenido</i>
</p>

</section>
<section>

<p>
Para hacer una PWA sencilla, sólo hay que hacer una página web
(aplicación), y añadir ciertas cosas
</p>
</section>
</section>
<section>
<section id="slide-manifest">
<h2 id="manifest">Manifest</h2>
</section>
<section>

<p>
El <a href="https://web.dev/add-manifest/">manifiesto</a> es un archivo de texto
con datos (JSON) que describe nuestra aplicación progresiva
</p>

</section>
<section>

<p>
Cuando hay un archivo <code>manifest.json</code> (o como le queramos llamar)
apuntado por nuestro <code>index.html</code>, el navegador sabrá que tenemos una
PWA
</p>

</section>
<section>

<div class="org-src-container">

<pre><code class="json" >{
  "short_name": "Nombre corto",
  "name": "Nombre largo de mi aplicación chula",
  "description": "La mejor PWA que existe",
  "icons": [ ],
  "start_url": "/",
  "background_color": "#26AF31",
  "display": "standalone",
  "scope": "/",
}
</code></pre>
</div>

</section>
<section>

<p>
Es importante declarar el "manifest" en <code>index.html</code>:
</p>

<div class="org-src-container">

<pre><code class="html" >&lt;link rel="manifest" href="manifest.json"&gt;
</code></pre>
</div>

</section>
<section>

<p>
Para que en el móvil se vea como una aplicación "nativa" en vez de como
una pestaña de navegador, añadimos esto a <code>manifest.json</code>:
</p>

<div class="org-src-container">

<pre><code class="json" >{  "display": "standalone"  }
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-service-workers">
<h2 id="service-workers">Service Workers</h2>
</section>
<section>

<p>
Son scripts que se ejecutan en navegador, <i>independientemente de una
página web</i>
</p>

</section>
<section>

<p>
No tienen acceso al DOM (porque no tienen acceso a una página)
</p>

</section>
<section>

<p>
Sólo funcionan con HTTPS
</p>

<p>
(Pero nos deja funcionar sin HTTPS cuando el dominio es <code>localhost</code>)
</p>

</section>
<section>

<p>
"Application"
<img src="ver_service_workers.png" alt="ver_service_workers.png">
</p>

</section>
<section>

<p>
Gracias a la tecnología de service workers, podemos <i>instalar</i> uno desde
nuestra página web
</p>

<p>
(Para esto, obviamente, necesitamos haber accedido a nuestra página por
primera vez)
</p>

</section>
<section>

<p>
Cuando el service worker esté instalado, el navegador recordará que hay
uno en nuestro dominio (la raíz de la URL), y lo usará cuando volvamos a
intentar acceder a ese dominio
</p>

<p>
<b>Aunque estemos sin conexión</b>
</p>
</section>
<section id="slide-instalar-un-service-worker">
<h3 id="instalar-un-service-worker">Instalar un service worker</h3>
<p>
Para instalar un service worker, sólo hay que ejecutar algo de código
JavaScript en nuestro <code>index.html</code>
</p>

</section>
<section>

<div class="org-src-container">

<pre><code class="html" >&lt;head&gt;
&lt;script&gt;
    // si nuestro navegador ejecuta service workers
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () =&gt; {
            navigator.serviceWorker.register('sw.js').then(reg =&gt; {
                console.log('Todo bien:', reg)
            }, function (err) {
                console.log('Fallo:', err)
            })
        })
    }
&lt;/script&gt;
&lt;/head&gt;
</code></pre>
</div>

</section>
<section>

<p>
En el código anterior, nuestro service worker estará en <code>sw.js</code> (lo
veremos un poco más adelante)
</p>
</section>
<section id="slide-borrar-service">
<h3 id="borrar-service">Borrar service</h3>
<p>
"Unregister"
<img src="unregister_sw.png" alt="unregister_sw.png">
</p>
</section>
<section id="slide-cache-de-archivos">
<h3 id="cache-de-archivos">Cache de archivos</h3>
<p>
A través de un service worker, podemos acceder al almacenamiento de
cache del navegador
</p>

<p>
Aquí podremos almacenar archivos (<code>index.html</code>, <code>app.js</code>, <code>dude.png</code>,
<code>fondo.css</code>), que estarán disponibles para acceso, independientemente
del estado de la conexión
</p>

</section>
<section>

<p>
En un <i>almacenamiento local al navegador</i>, lo que quiere decir que si
vamos a otro navegador (o a otro ordenador), no estarán los archivos ahí
</p>

</section>
<section>


<div id="org569ff7e" class="figure">
<p><img src="recurso_almacenado_cache.png" alt="recurso_almacenado_cache.png">
</p>
<p><span class="figure-number">Figura 1: </span>Podemos ver qué recursos se han almacenado en la cache</p>
</div>
</section>
<section id="slide-borrar-datos-de-la-cache">
<h3 id="borrar-datos-de-la-cache">Borrar datos de la cache</h3>
<p>
para forzar una recarga
<img src="borrar_cache_sw.png" alt="borrar_cache_sw.png">
</p>
</section>
<section id="slide-borrar-todo">
<h3 id="borrar-todo">¡Borrar todo!</h3>
<p>
<code>Clear site data</code>
<img src="clear_site_data.png" alt="clear_site_data.png">
</p>
</section>
</section>
<section>
<section id="slide-caching">
<h2 id="caching">Caching</h2>
</section>
<section>

<p>
Para tener una aplicación web que funcione sin conexión, simplemente
guardaremos los archivos en una cache
</p>

<p>
Después, tendremos un service worker que almacene los archivos, y los
recupere cuando volvamos a una URL
</p>

</section>
<section>

<p>
Y, cuando haya una versión nueva de los archivos (sólo lo sabremos
cuando estemos conectados) que actualice la cache
</p>

</section>
<section>

<p>
Para hacer el <i>caching</i> de archivos, y luego acceder a ellos, podríamos
usar la API de service workers
</p>

<p>
Pero vamos a usar
<a href="https://developers.google.com/web/tools/workbox/"><code>workbox</code></a>, que es
una librería que nos ahorra casi todo el trabajo con los service workers
</p>

</section>
<section>

<p>
Con <code>workbox</code>, es fácil activar la cache de archivos:
</p>

</section>
<section>

<p>
Ejemplo de archivo <code>sw.js</code>:
</p>

<div class="org-src-container">

<pre><code class="js" >importScripts('https://storage.googleapis.com/workbox-cdn/releases/5.1.2/workbox-sw.js')

console.log(`Workbox ${workbox ? 'sí' : 'no'} está funcionando`)

workbox.precaching.precacheAndRoute([
  {url: '/index.html', revision: null },
  {url: '/app.js', revision: null},
])
</code></pre>
</div>
</section>
<section id="slide-revisiones">
<h3 id="revisiones">Revisiones</h3>
<p>
Vemos que hemos puesto <code>{revision: null}</code>
</p>

<p>
Esto quiere decir que no hay información de revisión, y que la cache no
se actualizará cuando haya modificaciones
</p>

</section>
<section>

<p>
En <code>workbox</code>, esta información de revisiones es necesaria para que el
navegador reconozca qué archivos han cambiado
</p>

</section>
<section>

<p>
Pero mantener el número de revisión a mano es un trabajo tedioso
</p>
</section>
<section id="slide-workbox-cli">
<h3 id="workbox-cli"><code>workbox-cli</code></h3>
<p>
<code>workbox</code> ofrece una aplicación de línea de comandos que se encargará de
gestionar el valor de <code>revision</code>
</p>

</section>
<section>

<p>
Instalamos node.js (versión más nueva que haya):
</p>

<div class="org-src-container">

<pre><code class="sh" ># Iniciamos el proyecto node.js
npm init --yes
</code></pre>
</div>

</section>
<section>

<p>
Instalamos <code>workbox-cli</code>:
</p>

<div class="org-src-container">

<pre><code class="sh" ># en el directorio del proyecto
npm install -D workbox-cli
</code></pre>
</div>

</section>
<section>

<p>
Iniciamos el asistente de gestión de las revisiones:
</p>

<div class="org-src-container">

<pre><code class="sh" ># en el directorio del proyecto
npx workbox wizard
</code></pre>
</div>

</section>
<section>

<p>
Con esto, dejando las opciones por defecto, nos creará un archivo
<code>sw.js</code> (podemos cambiarle el nombre)
</p>

<p>
Este archivo reemplaza al que habíamos hecho a mano (así que no hay que
hacerlo)
</p>

</section>
<section>

<p>
Este archivo <code>sw.js</code> tiene nuestro nuevo service worker, que gestiona el
cache y las revisiones
</p>

</section>
<section>

<p>
Así, cuando hagamos cambios, la revisión cambiará y el navegador
recargará el recurso
</p>

<p>
<i>Hay que llamar a este comando cada vez que hagamos cambios</i>
</p>

<div class="org-src-container">

<pre><code class="sh" ># Para regenerar una versión, simplemente usamos la herramienta
# Esto asume que nuestra configuración se llama `workbox-config.js`
npx workbox generateSW
</code></pre>
</div>

</section>
<section>

<p>
Si hacemos un cambio, pero no regeramos el SW, no se recargará en el
navegador
</p>

</section>
<section>

<p>
En resumen:
</p>

<div class="org-src-container">

<pre><code class="sh" ># Instalar node.js (que viene con `npm`)
cd ruta_a_la_carpeta_de_mi_proyecto
npm init --yes
npm install -D workbox-cli
npx workbox wizard

# Repetir cada vez que haya cambios:
npx workbox generateSW
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-ciclo-de-trabajo">
<h2 id="ciclo-de-trabajo">Ciclo de trabajo</h2>
</section>
<section>

<p>
Tener que ejecutar <code>generateSW</code> cada vez que hacemos algo para probar es
tedioso
</p>

</section>
<section>

<p>
Una solución es desarrollar nuestra <i>app</i> como una aplicación web sin
service workers, y desplegarla cuando sea necesario
</p>

<p>
Así es mucho más rápido
</p>

</section>
<section>

<p>
Para eso, podemos tener:
</p>

<ul>
<li>un <code>index.html</code> que haga referencia al service worker</li>
<li>un <code>devel.html</code> que sea igual, pero que no use el service worker</li>

</ul>

</section>
<section>

<p>
Así, usaremos <code>devel.html</code> en desarrollo, pero desplegaremos con
<code>index.html</code>
</p>
</section>
<section id="slide-app-shell">
<h3 id="app-shell">App shell</h3>
<p>
El modelo de desarrollo de "app shell" consiste en hacer caching de todo
el <i>núcleo</i> de la aplicación (los HTML, CSS y JS que definen la
funcionalidad y la interfaz), y hacer que los datos (que podrían
cambiar) se carguen <i>dinámicamente</i>
</p>
</section>
</section>
<section>
<section id="slide-almacenamiento-local">
<h2 id="almacenamiento-local">Almacenamiento local</h2>
</section>
<section>

<p>
Las PWA se pueden beneficiar del
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">API
de almacenamiento local</a>
</p>
</section>
<section id="slide-usar-localstorage">
<h3 id="usar-localstorage">Usar <code>localStorage</code></h3>
</section>
<section>

<p>
Existe una variable
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"><code>localStorage</code></a>,
que es un objeto que permite guardar y leer valores
</p>

<p>
Estos valores se mantienen <i>entre sesiones</i> (a diferencia de
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage"><code>sessionStorage</code></a>),
y cada dominio tiene su propio objeto
</p>

</section>
<section>

<p>
Añadir o modificar una clave:
</p>

<div class="org-src-container">

<pre><code class="js" >localStorage.setItem('clave', 6)
localStorage.clave = 6
</code></pre>
</div>

<p>
<b>La clave se guarda siempre como <code>string</code></b>
</p>

</section>
<section>

<div class="org-src-container">

<pre><code class="js" >// para acceder al valor
localStorage.getItem('clave')
localStorage.clave
</code></pre>
</div>

</section>
<section>

<p>
Borrar:
</p>

<div class="org-src-container">

<pre><code class="js" >// borrar una clave
localStorage.removeItem('clave')
// borrar todo
localStorage.clear()
</code></pre>
</div>

</section>
<section>


<div id="org6d776de" class="figure">
<p><img src="localstorage_chrome.png" alt="localstorage_chrome.png" height="400">
</p>
<p><span class="figure-number">Figura 2: </span>Se puede ver la lista de datos guardados, por dominio</p>
</div>
</section>
</section>
<section>
<section id="slide-auditoría-con-lighthouse">
<h2 id="auditoría-con-lighthouse">Auditoría con <i>Lighthouse</i></h2>
</section>
<section>

<p>
Chrome incluye un sistema de auditoría de calidad de PWA,
<a href="https://developers.google.com/web/tools/lighthouse#devtools">Lighthouse</a>
</p>

</section>
<section>

<p>
Lighthouse nos emite un informe de la página en la que estamos, dándonos
nota a cada apartado
</p>

<p>
En particular, nos evalúa si la aplicación cumple los estándares de una
PWA
</p>

</section>
<section>


<div id="org4118ea2" class="figure">
<p><img src="lighthouse.png" alt="lighthouse.png" height="400">
</p>
<p><span class="figure-number">Figura 3: </span>Para arrancar la auditoría, sólo hay que seleccionar las opciones y darle al botón</p>
</div>
</section>
</section>
<section>
<section id="slide-ver-como-en-un-móvil">
<h2 id="ver-como-en-un-móvil">Ver como en un móvil</h2>
</section>
<section>

<p>
Para probar la aplicación en un móvil, podemos ir a nuestro dispositivo
y cargar la URL (en Chrome, por ejemplo)
</p>

</section>
<section>

<p>
Pero Chrome tiene una manera mucho más cómoda, haciendo que podamos ver,
en el navegador, la aplicación con el aspecto de un pantalla de móvil o
tableta
</p>

</section>
<section>


<div id="org9f9ddb9" class="figure">
<p><img src="toggle_device_toolbar.png" alt="toggle_device_toolbar.png" height="400">
</p>
<p><span class="figure-number">Figura 4: </span>Podemos ver nuestra PWA como se vería en un dispositivo móvil</p>
</div>

</section>
<section>


<div id="orge14a11c" class="figure">
<p><img src="cambiar_opciones_device.png" alt="cambiar_opciones_device.png" height="400">
</p>
<p><span class="figure-number">Figura 5: </span>Podemos elegir las opciones del dispositivo que estamos simulando</p>
</div>
</section>
</section>
</div>
</div>
<script src="node_modules/reveal.js/dist/reveal.js"></script>
<script src="node_modules/reveal.js/plugin/search/search.js"></script>
<script src="node_modules/reveal.js/plugin/highlight/highlight.js"></script>
<script src="node_modules/reveal.js/plugin/zoom/zoom.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,

transition: 'none',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealSearch, RevealHighlight, RevealZoom ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
