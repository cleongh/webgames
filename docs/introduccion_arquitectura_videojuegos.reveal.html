<!DOCTYPE html><html lang="es"><head><meta charset="utf-8"><title>Introducción a la arquitectura de videojuegos</title><meta name="author" content="Carlos León"><style>.underline{text-decoration:underline}</style><link rel="stylesheet" href="tooling.reveal.e38fa0d8.css"><link rel="stylesheet" href="tooling.reveal.a866bf8d.css" id="theme"><link rel="stylesheet" href="tooling.reveal.c1a625de.css"><link rel="stylesheet" href="tooling.reveal.fdb16a0d.css"></head><body> <div class="reveal"> <div class="slides"> <section id="sec-title-slide"> <h1 class="title">Introducción a la arquitectura de videojuegos</h1><h2 class="author">Carlos León</h2><h2 class="email"><a href="mailto:cleon@ucm.es">cleon@ucm.es</a></h2> </section> <section> <section id="slide-qué-es-la-arquitectura-de-un-juego"> <h2 id="qué-es-la-arquitectura-de-un-juego">Qué es la arquitectura de un juego</h2> </section> <section> <p> Los videojuegos son, normalmente, sistemas complejos y grandes </p> </section> <section> <p> Tienen muchos subsistemas que, además, gestionan aspectos distintos y hasta tecnologías heterogéneas </p> </section> <section> <p> La complejidad puede crecer tanto, que carecer de un diseño global coherente <i>puede hacer inmanejable el desarrollo</i> </p> </section> <section> <p> Por eso se usan <i>arquitecturas</i> </p> <p> Un arquitectura, análoga a la de un edificio, es una manera de organizar el código para hacer el desarrollo más eficiente </p> </section> <section> <p> Pensad en sistemas que hacen muchas cosas, como Unity </p> <p> ¿Podríais implementar Unity? </p> </section> <section> <p> Unity es un motor de juego entero </p> <p> (y, además, un editor) </p> </section> <section> <p> Cada parte de un motor de juego como Unity tiene que: </p> <ul> <li>Ser modificable</li> <li>Ser ampliable</li> <li>Ser independiente</li> <li>Comunicarse con las demás</li> <li>Hacer todo esto de forma que los <i>programadores</i> empleen el mínimo esfuerzo</li> </ul> </section> </section> <section> <section id="slide-por-qué-pensar-en-la-arquitectura"> <h2 id="por-qué-pensar-en-la-arquitectura">Por qué pensar en la arquitectura</h2> </section> <section> <p> La arquitectura software de un videojuego no es para la <i>máquina</i>, es para el <i>programador</i> </p> <p> Pensad en un juego cuyo código comunique los módulos de varias maneras distintas </p> </section> <section> <p> Cuando se tienen 6 subsistemas distintos, la organización del código es <i>indispensable</i> </p> <p> Además, puede tener impacto en la eficiencia </p> </section> </section> <section> <section id="slide-repaso-de-programación-orientada-a-objetos"> <h2 id="repaso-de-programación-orientada-a-objetos">Repaso de programación orientada a objetos</h2> </section> <section> <p> Un paradigma de programación muy usado para sistemas software que requieren arquitecturas complejas es la <i>programación orientada a objetos</i> basada en clases </p> </section> <section id="slide-clases"> <h3 id="clases">Clases</h3> </section> <section> <p> Las clases son los tipos, las estructuras de las que se crean instancias </p> <div id="orgfa9a987" class="figure"> <p><img src="umlbasico.d456fa10.svg" alt="umlbasico.pu" height="400"> </p> <p><span class="figure-number">Figura 1: </span>Ejemplo de clases</p> </div> </section> <section id="slide-instancias"> <h3 id="instancias">Instancias</h3> </section> <section> <p> Las instancias son cada uno de los elementos/objetos concretos que tienen las propiedades (atributos y métodos) de una clase </p> </section> <section> <p> Aquí, <code>player</code> y <code>enemy</code> son instancias de <code>Player</code> y <code>Enemy</code> respectivamente: </p> <div class="org-src-container"> <pre><code class="cpp">Player player("player", 10, 10, 0, 0, 100);
Enemy enemy("enemy", 15, 15, 0, 0, &amp;player);
</code></pre> </div> </section> <section id="slide-relaciones"> <h3 id="relaciones">Relaciones</h3> </section> <section> <p> Las clases, como módulos, se relacionan en un sistema </p> <p> Hay muchos tipos de relaciones y muchas maneras de usarlas, aquí sólo comentamos algunas </p> </section> <section id="slide-herencia"> <h3 id="herencia">Herencia</h3> </section> <section> <p> Las clases pueden <i>heredarse</i>, de forma que una clase <i>hija</i> <b>es-una</b> (<code>is-a</code>) clase padre también </p> <div id="org9d441c7" class="figure"> <p><img src="herencia.95a770ca.svg" alt="herencia.pu" height="400"> </p> <p><span class="figure-number">Figura 2: </span>Clases para estructurar un juego</p> </div> </section> <section id="slide-uso"> <h3 id="uso">Uso</h3> </section> <section> <p> Las clases pueden <i>usarse</i> unas a otras, de forma que se <i>pasen mensajes</i> </p> <div id="org07f6d5c" class="figure"> <p><img src="asociacion.5d09b292.svg" alt="asociacion.pu" height="400"> </p> <p><span class="figure-number">Figura 3: </span>Clases que se usan</p> </div> </section> <section id="slide-composición"> <h3 id="composición">Composición</h3> <p> Las clases pueden <i>componerse</i>, de forma que la relación es muy fuerte. Así, si desaparece el todo, <i>desaparecen las partes también</i> </p> <div id="org36a07c5" class="figure"> <p><img src="composicion.5dbe255b.svg" alt="composicion.pu" height="200"> </p> <p><span class="figure-number">Figura 4: </span>Composición de clases</p> </div> </section> </section> <section> <section id="slide-arquitecturas-basadas-en-herencia"> <h2 id="arquitecturas-basadas-en-herencia">Arquitecturas basadas en herencia</h2> </section> <section> <p> La programación orientada a objetos clásica permite una manera de modular sistemas </p> </section> <section> <p> Entre otros, los videojuegos son razonablemente complejos y manejan dos aspectos que hay que gestionar: </p> <ul> <li>Modelo de datos (orco, espada, mundo&#x2026;)</li> <li>Modelo de sistemas (gráficos, sonido, entrada&#x2026;)</li> </ul> </section> <section> <p> Muchos videojuegos se han modelado con patrones de herencia </p> </section> <section> <p> ¿Por qué <i>no</i> seguimos haciéndolo? </p> <p> (Hay mucha gente que sigue haciéndolo, y en muchos casos no es un problema) </p> </section> <section id="slide-el-problema-de-la-herencia"> <h3 id="el-problema-de-la-herencia">El problema de la herencia</h3> <p> La herencia se basa en la relación <i>es-un</i> </p> </section> <section> <p> Muchas veces: </p> <ul> <li>todos los <code>Enemigos</code> son <code>Movibles</code></li> <li>todos los <code>Jugadores</code> son <code>Personajes</code></li> <li>todos los proyectiles son objetos <code>Físicos</code></li> </ul> </section> <section> <p> Intentémoslo: </p> <p> <code>entidad</code> → <code>movible</code> → <code>visible</code> → <code>jugador</code> </p> </section> <section> <div id="orgefc457d" class="figure"> <p><img src="herenciacorrecta.2b4fbf61.svg" alt="herenciacorrecta.pu" height="400"> </p> <p><span class="figure-number">Figura 5: </span>Herencia básica</p> </div> </section> <section> <p> ¿Pero qué pasa cuando queremos crear&#x2026; </p> <ul> <li>&#x2026; un personaje <i>invisible</i>?</li> <li>&#x2026; un proyectil manejado por la red?</li> <li>&#x2026; un enemigo que no se mueve?</li> </ul> </section> <section> <p> Ahora hagamos un jugador que no se puede mover: </p> <div id="org85f8dc6" class="figure"> <p><img src="herenciaproblema.97fa1f27.svg" alt="herenciaproblema.pu" height="400"> </p> <p><span class="figure-number">Figura 6: </span>Herencia problemática</p> </div> </section> <section> <p> A finales de los 90 esto se convirtió en un problema claro, y las arquitecturas por componentes de entidad se generalizaron </p> <p> En general (y mucho en diseño de videojuegos) preferimos <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">composición antes que herencia</a> </p> </section> </section> <section> <section id="slide-sistemas-de-componentes"> <h2 id="sistemas-de-componentes">Sistemas de componentes</h2> </section> <section> <p> Para aliviar los problemas relativos de la estructura de herencia (con <i>es-un</i>), usamos <a href="https://en.wikipedia.org/wiki/Entity_component_system"><b>componentes</b></a> </p> </section> <section id="slide-qué-es-un-componente"> <h3 id="qué-es-un-componente">Qué es un componente</h3> </section> <section> <p> Un componente es un aspecto, una propiedad o característica que tiene una <i>entidad</i> </p> </section> <section> <p> Por ejemplo, podemos tener un componente que sirva para pintar </p> <p> Este componente se usará <i>sólo para pintar</i>, y no sabrá nada del sonido </p> </section> <section> <p> También podríamos añadir un componente para modelar un inventario </p> <p> El componente no sabrá nada de la entidad que lo contiene. Sólo tendrá información de cómo guardar objetos </p> </section> <section> <p> Puede haber un componente para las entidades que son visibles, y otro componente para las entidades que tienen respuesta física al sistema </p> </section> <section> <table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"> <colgroup> <col class="org-left"> <col class="org-left"> <col class="org-left"> </colgroup> <thead> <tr> <th scope="col" class="org-left">Entidad</th> <th scope="col" class="org-left">Física</th> <th scope="col" class="org-left">Visible</th> </tr> </thead> <tbody> <tr> <td class="org-left">Nube</td> <td class="org-left">✗</td> <td class="org-left">✓</td> </tr> <tr> <td class="org-left">Orco</td> <td class="org-left">✓</td> <td class="org-left">✓</td> </tr> <tr> <td class="org-left">Trigger</td> <td class="org-left">✗</td> <td class="org-left">✗</td> </tr> <tr> <td class="org-left">Espíritu</td> <td class="org-left">✓</td> <td class="org-left">✗</td> </tr> </tbody> </table> </section> <section id="slide-entonces-qué-es-una-entidad"> <h3 id="entonces-qué-es-una-entidad">Entonces, ¿qué es una entidad?</h3> </section> <section> <p> Una <i>entidad</i> no es más que un identificador, un elemento vacío que <i>contiene componentes</i> </p> <p> La entidad no tiene información de cómo pintarse, ni de cómo moverse </p> </section> <section> <ul> <li>Un personaje ("player") será una entidad</li> <li>Un <i>trigger</i>, también</li> <li>Un botón</li> <li>Los enemigos</li> </ul> </section> <section> <p> Es decir, una entidad es algo genérico que <i>sólo tiene una lista de componentes</i> </p> <div class="org-src-container"> <pre><code class="js">var entidad = {
   id          : 4,
   componentes : [
        drawable,
        sound,
        movable,
        physics
   ]
}
</code></pre> </div> </section> <section> <p> La entidad <b>delega</b> en sus componentes todo el comportamiento: </p> <div class="org-src-container"> <pre><code class="js">// en cada ciclo (tick), la entidad simplemente 
// delega en sus componentes
Entity.prototype.tick = function() {
    this.components.forEach(function(component) {
        component.tick();
    });
}
</code></pre> </div> </section> </section> <section> <section id="slide-sistemas-de-entidades"> <h2 id="sistemas-de-entidades">Sistemas de entidades</h2> </section> <section> <p> Cada componente tiene información sobre un aspecto del juego </p> <ul> <li>Física</li> <li>Gráficos</li> <li>Sonido</li> <li>Entrada</li> <li>Colisiones</li> <li>Bandos</li> <li>Inventario</li> <li>&#x2026;</li> </ul> </section> <section id="slide-sistemas"> <h3 id="sistemas">Sistemas</h3> </section> <section> <p> Tiene sentido, por lo tanto, <b>dividir</b> el código en partes (hacer módulos) que se encarguen de trabajar los dominios correspondientes </p> <p> Cada uno de estos módulos suelen llamarse <i>sistemas</i> o <i>subsistemas</i> </p> </section> <section> <p> Cada sistema suele manejar y tener acceso a los componentes correspondientes </p> <p> Sí, en arquitectura no hay teorías generales. Las cosas "suelen" hacerse de una u otra manera </p> </section> <section> <p> Por ejemplo, en la parte física no suele influir mucho el sonido: </p> <div id="org58831c7" class="figure"> <p><img src="sistemascomponentes.009ae0c6.svg" alt="sistemascomponentes.pu" height="400"> </p> <p><span class="figure-number">Figura 7: </span>Relación entre sistemas y componentes</p> </div> </section> <section> <p> Así pues, <code>AudioComponent</code> sólo se relaciona con <code>AudioManager</code> (y, probablemente, con <code>Entity</code>) pero no sabe nada de <code>PhysicsManager</code> </p> </section> </section> <section> <section id="slide-mixins-una-aproximación-a-los-componentes"> <h2 id="mixins-una-aproximación-a-los-componentes"><i>Mixins</i>: una aproximación a los componentes</h2> </section> <section> <p> Un <i>mixin</i> es una clase pensada para contener funcionalidad, pero no ser autónoma </p> </section> <section> <p> Usar <i>mixins</i> no representa <i>especialización</i> (<i>es-un</i>) </p> </section> <section> <p> Es como una <i>interfaz</i> (generalmente una clase puede incluir varios <i>mixins</i>), pero sí que tiene código </p> </section> <section> <p> En JavaScript, una funcionalidad aproximada de <i>mixin</i> se puede conseguir con <code>Object.assign()</code>: </p> <div class="org-src-container"> <pre><code class="js">class Sword extends Object {}
class Takeable { putInInventory() {/*...*/} }

Object.assign(Sword.prototype, Takeable);
</code></pre> </div> </section> <section> <div id="org717cdd0" class="figure"> <p><img src="mixin.9c839949.svg" alt="mixin.pu" height="400"> </p> <p><span class="figure-number">Figura 8: </span>Ejemplo en UML con un <i>mixin</i></p> </div> </section> <section> <p> <code>Object.assign()</code> sólo copia propiedades entre objetos, no hay <i>herencia</i> </p> </section> </section> <section> <section id="slide-hay-muchas-maneras-de-hacer-arquitecturas"> <h2 id="hay-muchas-maneras-de-hacer-arquitecturas">Hay muchas maneras de hacer arquitecturas</h2> </section> <section> <p> En este tema hemos visto (y veremos) <i>una manera</i> de hacer arquitecturas por componentes, pero hay muchas </p> </section> <section> <p> Paso de mensajes, entidades puras, sistemas independientes o acoplados&#x2026; cada decisión de diseño depende del problema a resolver </p> </section> <section> <blockquote> <p> No hay una solución general para todos los problemas </p> </blockquote> </section> </section> </div> </div> <script src="tooling.reveal.ffb33b1a.js"></script> <script src="tooling.reveal.f05d24be.js"></script> <script src="tooling.reveal.1feea775.js"></script> <script src="tooling.reveal.d2982244.js"></script> <script>Reveal.initialize({controls:!0,progress:!0,history:!0,center:!0,slideNumber:"c",rollingLinks:!1,keyboard:!0,mouseWheel:!1,fragmentInURL:!1,hashOneBasedIndex:!1,pdfSeparateFragments:!0,overview:!0,transition:"none",transitionSpeed:"default",plugins:[RevealSearch,RevealHighlight,RevealZoom],dependencies:[]});</script> </body></html>