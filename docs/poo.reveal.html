<!DOCTYPE html><html lang="es"><head><meta charset="utf-8"><title>Modelado orientado a objetos</title><meta name="author" content="Carlos León"><style>.underline{text-decoration:underline}</style><link rel="stylesheet" href="tooling.reveal.e38fa0d8.css"><link rel="stylesheet" href="tooling.reveal.a866bf8d.css" id="theme"><link rel="stylesheet" href="tooling.reveal.c1a625de.css"><link rel="stylesheet" href="tooling.reveal.fdb16a0d.css"></head><body> <div class="reveal"> <div class="slides"> <section id="sec-title-slide"> <h1 class="title">Modelado orientado a objetos</h1><h2 class="author">Carlos León</h2><h2 class="email"><a href="mailto:cleon@ucm.es">cleon@ucm.es</a></h2> </section> <section> <section id="slide-modelado-de-problemas"> <h2 id="modelado-de-problemas">Modelado de problemas</h2> </section> <section> <p> Programar es expresar un problema en un lenguaje de programación dado. Modelar representa un paso intermedio en el que se capturan y organizan los aspectos importantes de un problema </p> </section> <section> <p> El modelado de un problema es independiente del lenguaje de programación que se elija pero el lenguaje seleccionado condiciona la facilidad con la que podemos codificar el modelo </p> </section> <section> <p> Muchas actividades creativas incluyen modelos intermedios entre la realidad y su expresión en el medio final </p> </section> <section> <div id="org958c44f" class="figure"> <p><img src="batman-storyboard.0c6f3c9e.jpg" alt="batman-storyboard.jpg"> </p> <p><span class="figure-number">Figura 1: </span>Una página del story board de la serie de animación de Batman</p> </div> </section> <section> <p> Los <i>storyboard</i> se utilizan para planificar las secuencias de acción. Capturan los momentos clave de la secuencia </p> </section> <section> <p> Este mapa muestra el paso de "Ella-Laraña", usado para mantener la coherencia del escenario descrito </p> <div id="org0f091a9" class="figure"> <p><img src="lotr-notes.8bf22a10.jpg" alt="lotr-notes.jpg"> </p> <p><span class="figure-number">Figura 2: </span>Notas de Tolkien para la elaboración del Señor de los Anillos</p> </div> </section> <section> <p> Un diseño de un mapa del videojuego Mario. Las herramientas digitales han permitido la automatización de modelos en software </p> <div id="org7d0bd84" class="figure"> <p><img src="mario-level-design.7c102f00.png" alt="mario-level-design.png"> </p> <p><span class="figure-number">Figura 3: </span>Mapa del video juego Mario en papel cuadriculado</p> </div> </section> <section> <p> El diagrama de flujo de cómo se llaman las distintas funciones de un script de Unity </p> <div id="orge2edc8e" class="figure"> <p><img src="monobehaviour-flowchart.cb8cc034.png" alt="monobehaviour-flowchart.png" height="400"> </p> <p><span class="figure-number">Figura 4: </span>Diagrama de flujo del ciclo de vida de un script en Unity</p> </div> </section> <section> <p> La programación orientada a objetos es una técnica de <b>modelado de problemas</b> en la que se pone especial énfasis a dos conceptos: <b>objetos</b> y <b>paso de mensajes</b> </p> </section> </section> <section> <section id="slide-programación-orientada-a-objetos"> <h2 id="programación-orientada-a-objetos">Programación orientada a objetos</h2> </section> <section id="slide-objetos"> <h3 id="objetos">Objetos</h3> <p> Los objetos son <b>representaciones de los aspectos de un problema</b> </p> <ul> <li>Desempeñan <b>un rol solamente</b></li> <li>Exponen un conjunto de <b>funcionalidad concreta</b>: la <a href="https://en.wikipedia.org/wiki/Application_programming_interface#Libraries_and_frameworks">API</a></li> <li><b>Ocultan</b> cómo realizan esa funcionalidad</li> </ul> </section> <section id="slide-paso-de-mensajes"> <h3 id="paso-de-mensajes">Paso de mensajes</h3> <p> Los mensajes son <b>peticiones de acción</b> de un objeto a otro </p> <ul> <li>Parten de un objeto <b>remitente</b>&#x2026;</li> <li>&#x2026; hacia un objeto <b>destinatario</b></li> <li>Codifican qué <b>funcionalidad de la API</b> se precisa</li> </ul> </section> <section id="slide-modelado-orientado-a-objetos"> <h3 id="modelado-orientado-a-objetos">Modelado orientado a objetos</h3> <p> La definición de objetos y las interacciones entre los mismos modelan el problema </p> </section> <section> <p> Vamos a modelar informalmente el video juego <a href="https://en.wikipedia.org/wiki/Space_Invaders">Space Invaders</a> </p> </section> <section> <div id="org5f86b92" class="figure"> <p><img src="space-invaders.7c040fbe.jpg" alt="space-invaders.jpg"> </p> <p><span class="figure-number">Figura 5: </span>Captura de pantalla del video juego space invaders donde se aprecian naves enemigas, la nave amiga, marcadores de vidas y puntuación, proyectiles amigos y enemigos y las defensas de la nave</p> </div> </section> <section id="slide-identificando-objetos"> <h3 id="identificando-objetos">Identificando objetos</h3> <p> Una técnica para identificar objetos es pensar en <b>poner nombres</b> </p> <div id="org9d2bb12" class="figure"> <p><img src="space-invaders-objects.10ab153d.svg" alt="space-invaders-objects.svg" class="org-svg"> </p> <p><span class="figure-number">Figura 6: </span>Captura de Space Invaders donde se distinguen los objetos</p> </div> </section> <section> <p> Algunos objetos: nave amiga, enemigo 1, enemigo 2, enemigo 3, disparo amigo, disparo enemigo 1, disparo enemigo 2, defensa 1, defensa 2, marcador de vidas, marcador de puntuación </p> </section> <section id="slide-tipos-de-objetos-e-instancias"> <h3 id="tipos-de-objetos-e-instancias">Tipos de objetos e instancias</h3> <p> Queda claro de un vistazo que muchos objetos concretos pertenecen a familias o <b>tipos</b> de objetos </p> <p> Conviene recordar que también se los llama <b>clases</b> </p> </section> <section> <p> Los tipos de objetos <b>especifican propiedades y comportamientos comunes</b> a todos ellos aunque individualmente sean distintos </p> </section> <section> <div id="orgd6cce1c" class="figure"> <p><img src="space-invaders-types.4d46f9e6.svg" alt="space-invaders-types.svg" class="org-svg"> </p> <p><span class="figure-number">Figura 7: </span>Captura de Space Invaders donde se distinguen los distintos tipos de objetos: marcadores, defensas, enemigos, protagonista y disparos</p> </div> </section> <section> <p> Los <b>valores</b> de un tipo son cada uno de los objetos individuales </p> <p> El enemigo especial, así como cada uno de los otros enemigos será un valor distinto del <b>tipo enemigo</b> </p> </section> <section> <p> Cuando utilizamos la terminología de clases, los valores se convierten en <b>instancias de la clase</b> </p> <p> En los modelos de objetos es más conveniente trabajar con tipos de objetos </p> </section> <section> <p> marcador, defensa, enemigo, protagonista y disparo <img src="space-invaders-object-diagram.c7447255.svg" alt="space-invaders-object-diagram.svg" class="org-svg"> </p> </section> <section id="slide-interfaces-api-y-métodos"> <h3 id="interfaces-api-y-métodos">Interfaces (API) y métodos</h3> <p> Vamos a tratar de determinar la API de nuestros tipos de objetos. Para eso nos guiarán las interacciones propias del juego </p> <iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/UZlEXl9xgR 8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen> </iframe> </section> <section> <p> Un ejemplo: <i>los enemigos se mueven todos juntos hacia un lado, avanzan una línea y se mueven hacia el otro lado mientras disparan aleatoriamente</i> </p> <p> Vamos a <b>buscar verbos</b> esta vez: <b>mover</b>, <b>avanzar</b> y <b>disparar</b> </p> </section> <section> <p> Para poder implementar el comportamiento de los enemigos, estos tienen que poder moverse hacia los lados, avanzar y disparar </p> <p> Así, tendrán que permitir que les envíen mensajes pidiendo una de estas operaciones </p> </section> <section> <p> A las cosas que puede hacer un objeto se las denomina <b>métodos</b> </p> <p> izquierda, moverse a la derecha, avanzar y disparar. <img src="space-invaders-enemy-api.d8daa944.svg" alt="space-invaders-enemy-api.svg" class="org-svg"> </p> </section> <section id="slide-estado-y-atributos"> <h3 id="estado-y-atributos">Estado y atributos</h3> <p> Los objetos no sólo pueden hacer cosas sino que además capturan características de las entidades a las que representan </p> </section> <section> <p> Cada enemigo, por ejemplo, tiene un <b>gráfico distinto</b>, una <b>puntuación diferente</b>, una <b>posición en pantalla</b> y además recordará en qué <b>dirección se estaba moviendo</b> </p> </section> <section> <p> El estado no se suele exponer de forma directa en la API </p> <p> Piensa en el caso de los enemigos: incluso si estos tienen una posición, es preferible tener métodos específicos con los que manipular la posición (como "mover a la izquierda" o "mover a la derecha") en lugar de dar libre acceso a la posición </p> </section> <section> <p> A las características de un objeto se las denomina <b>atributos</b> </p> <div id="org9bf8b74" class="figure"> <p><img src="space-invaders-enemy-state.27728855.svg" alt="space-invaders-enemy-state.svg" class="org-svg"> </p> <p><span class="figure-number">Figura 8: </span>Estado del enemigo mostrando: gráfico, dirección actual, posición y puntuación.</p> </div> </section> <section id="slide-el-proceso-de-modelado-es-iterativo"> <h3 id="el-proceso-de-modelado-es-iterativo">El proceso de modelado es iterativo</h3> <p> Al definir algunas acciones, hemos introducido nuevos nombres como <b>posición</b> o <b>dirección</b> que se convertirán en tipos de objetos con sus propios constructores </p> </section> <section id="slide-constructores-y-creación-de-objetos"> <h3 id="constructores-y-creación-de-objetos">Constructores y creación de objetos</h3> <p> Pensemos en la interacción de disparo: <i>cuando el jugador pulsa el botón de disparo, aparece un proyectil delante de la nave amiga que avanza hasta alcanzar la parte superior de la pantalla o colisionar con un enemigo</i> </p> <p> El proyectil no estaba ahí antes y tendrá que ser creado en el momento del disparo </p> </section> <section> <p> Otro ejemplo, la preparación del nivel antes de jugar: <i>aparecen 55 enemigos en pantalla, 5 filas de 11 enemigos con la siguiente configuración: 1 fila de enemigos de la especie 1, dos filas de la especie 2, 1 de la especie 3 y 1 de la especie 4</i> </p> </section> <section> <p> Está claro que no queremos escribir los 55 enemigos individualmente </p> <p> Además, dado que todos pertenecen al tipo enemigo, queda claro que serán todos muy parecidos </p> </section> <section> <p> Lo que necesitamos es un mecanismo de <b>generación automática de objetos</b> </p> <p> Cada lenguaje ofrece formas distintas de crear objetos </p> </section> <section> <p> Nosotros vamos a añadir un nuevo objeto, el <b>contructor</b>, cuya tarea es la de generar objetos de un tipo dado </p> <p> Así, encontraremos <b>un contructor por tipo</b> </p> </section> <section> <div id="org27a4362" class="figure"> <p><img src="space-invaders-constructors.ad9d88dd.svg" alt="space-invaders-constructors.svg" class="org-svg"> </p> <p><span class="figure-number">Figura 9: </span>Estado del enemigo mostrando: gráfico, dirección actual, posición y puntuación</p> </div> </section> <section> <p> Los constructores tienen una API muy sencilla: <b>nuevo objeto</b> </p> <p> Este método crea un nuevo objeto de un tipo dado </p> </section> <section> <div id="org9f97b9f" class="figure"> <p><img src="space-invaders-constructor-detail.275a97a7.svg" alt="space-invaders-constructor-detail.svg" class="org-svg"> </p> <p><span class="figure-number">Figura 10: </span>Una factoría para un tipo cualquiera con un sólo método: nuevo objeto.</p> </div> </section> <section> <p> Los constructores suelen permitir personalizar partes del objeto que están creando de forma que se le pueda decir algo como "crea un disparo con esta posición, este gráfico y esta dirección de avance" </p> </section> <section> <div id="org0688fca" class="figure"> <p><img src="space-invaders-constructor-example.efbb7fa4.svg" alt="space-invaders-constructor-example.svg" class="org-svg"> </p> <p><span class="figure-number">Figura 11: </span>Una factoría para un tipo cualquiera con un sólo método: nuevo objeto</p> </div> </section> <section id="slide-relaciones-entre-tipos"> <h3 id="relaciones-entre-tipos">Relaciones entre tipos</h3> <p> Cuando modelamos, surgen relaciones de forma natural </p> <p> Los enemigos <b>tienen</b> una posición </p> <p> La nave amiga <b>crea</b> disparos </p> </section> <section> <p> Nuestro cerebro tiende a establecer jerarquías entre objetos creando tipos más generalistas </p> <p> Por ejemplo: en vez de pensar en enemigos y protagonista por separado, es posible pensar en <b>naves</b> </p> </section> <section> <p> El <b>tipo nave</b> reúne los métodos y atributos comunes de la nave protagonista y enemigos </p> </section> <section> <div id="orgd71c317" class="figure"> <p><img src="space-invaders-hierarchy.b7a61e44.svg" alt="space-invaders-hierarchy.svg" class="org-svg"> </p> <p><span class="figure-number">Figura 12: </span>La jerarquía entre los enemigos, la nave protagonista y el super-tipo nave</p> </div> </section> <section> <p> Esta jerarquía establece <b>relaciones de herencia</b> también llamadas relaciones "<b>es un(a)</b>" dado que <b>el protagonista es una nave</b> y <b>el enemigo es una nave</b> </p> </section> <section> <p> Se dice que <b>el tipo enemigo extiende al tipo nave</b> añadiendo avanzar a la API, y la puntuación y la última dirección de desplazamiento al estado </p> </section> <section> <p> La nave amiga no añade ningún método nuevo pero <b>redefine o sobreescribe</b> el método disparar para que dispare hacia arriba </p> </section> <section> <p> Como hay nuevos tipos, tendremos nuevos constructores </p> <p> Los viejos constructores pueden delegar parte de la creación del objeto (las partes comunes) a los nuevos </p> </section> <section> <div id="org80508ba" class="figure"> <p><img src="space-invaders-hierarchy-constructor.fade4d20.svg" alt="space-invaders-hierarchy-constructor.svg" class="org-svg"> </p> <p><span class="figure-number">Figura 13: </span>Cuando se pide al constructor de enemigos un enemigo, este pide al constructor de naves una nave, la personaliza para que sea un enemigo y devuelve el enemigo</p> </div> </section> <section> <p> De esta forma al pedir un enemigo, el constructor de enemigos pedirá una nave al constructor de naves </p> <p> Tomará esa nave, la modificará para que sea un enemigo y devolverá un enemigo </p> </section> <section> <blockquote> <p> OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things </p> </blockquote> <p> <a href="http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">Alan Kays sobre la programación orientada a objetos</a> </p> </section> </section> </div> </div> <script src="tooling.reveal.62c78f3a.js"></script> <script src="tooling.reveal.f05d24be.js"></script> <script src="tooling.reveal.d8230ad1.js"></script> <script src="tooling.reveal.d2982244.js"></script> <script>Reveal.initialize({controls:!0,progress:!0,history:!0,center:!0,slideNumber:"c",rollingLinks:!1,keyboard:!0,mouseWheel:!1,fragmentInURL:!1,hashOneBasedIndex:!1,pdfSeparateFragments:!0,overview:!0,transition:"none",transitionSpeed:"default",plugins:[RevealSearch,RevealHighlight,RevealZoom],dependencies:[]});</script> </body></html>