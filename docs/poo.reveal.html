<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Modelado orientado a objetos</title><meta name="author" content="Carlos León"><style>.underline{text-decoration:underline}</style><link rel="stylesheet" href="/tooling.reveal.4b097e00.css"><link rel="stylesheet" href="/tooling.reveal.64dafdde.css" id="theme"><link rel="stylesheet" href="/tooling.reveal.fdb16a0d.css"></head><body> <div class="reveal"> <div class="slides"> <section id="sec-title-slide"> <h1 class="title">Modelado orientado a objetos</h1><h2 class="author">Carlos León</h2><p class="date">Created: 2025-01-16 jue 10:30</p> </section> <section> <section id="slide-modelado-de-problemas"> <h2 id="modelado-de-problemas"><span class="section-number-2">1.</span> Modelado de problemas</h2> </section> <section> <p> Programar es expresar un problema en un lenguaje de programación dado. Modelar representa un paso intermedio en el que se capturan y organizan los aspectos importantes de un problema </p> </section> <section> <p> El modelado de un problema es independiente del lenguaje de programación que se elija pero el lenguaje seleccionado condiciona la facilidad con la que podemos codificar el modelo </p> </section> <section> <p> Muchas actividades creativas incluyen modelos intermedios entre la realidad y su expresión en el medio final </p> </section> <section> <div id="orgf2236dd" class="figure"> <p><img src="/batman-storyboard.0c6f3c9e.jpg" alt="batman-storyboard.jpg"> </p> <p><span class="figure-number">Figure 1: </span>Una página del story board de la serie de animación de Batman</p> </div> </section> <section> <p> Los <i>storyboard</i> se utilizan para planificar las secuencias de acción. Capturan los momentos clave de la secuencia </p> </section> <section> <p> Este mapa muestra el paso de "Ella-Laraña", usado para mantener la coherencia del escenario descrito </p> <div id="org531f8f5" class="figure"> <p><img src="/lotr-notes.8bf22a10.jpg" alt="lotr-notes.jpg"> </p> <p><span class="figure-number">Figure 2: </span>Notas de Tolkien para la elaboración del Señor de los Anillos</p> </div> </section> <section> <p> Un diseño de un mapa del videojuego Mario. Las herramientas digitales han permitido la automatización de modelos en software </p> <div id="org63e75b6" class="figure"> <p><img src="/mario-level-design.18605ed5.png" alt="mario-level-design.png"> </p> <p><span class="figure-number">Figure 3: </span>Mapa del video juego Mario en papel cuadriculado</p> </div> </section> <section> <p> El diagrama de flujo de cómo se llaman las distintas funciones de un script de Unity </p> <div id="org004c573" class="figure"> <p><img src="/monobehaviour-flowchart.13c23485.png" alt="monobehaviour-flowchart.png"> </p> <p><span class="figure-number">Figure 4: </span>Diagrama de flujo del ciclo de vida de un script en Unity</p> </div> </section> <section> <p> La programación orientada a objetos es una técnica de <b>modelado de problemas</b> en la que se pone especial énfasis a dos conceptos: <b>objetos</b> y <b>paso de mensajes</b> </p> </section> </section> <section> <section id="slide-programación-orientada-a-objetos"> <h2 id="programación-orientada-a-objetos"><span class="section-number-2">2.</span> Programación orientada a objetos</h2> </section> <section id="slide-objetos"> <h3 id="objetos"><span class="section-number-3">2.1.</span> Objetos</h3> <p> Los objetos son <b>representaciones de los aspectos de un problema</b> </p> <ul> <li>Desempeñan <b>un rol solamente</b></li> <li>Exponen un conjunto de <b>funcionalidad concreta</b>: la <a href="https://en.wikipedia.org/wiki/Application_programming_interface#Libraries_and_frameworks">API</a></li> <li><b>Ocultan</b> cómo realizan esa funcionalidad</li> </ul> </section> <section id="slide-paso-de-mensajes"> <h3 id="paso-de-mensajes"><span class="section-number-3">2.2.</span> Paso de mensajes</h3> <p> Los mensajes son <b>peticiones de acción</b> de un objeto a otro </p> <ul> <li>Parten de un objeto <b>remitente</b>&#x2026;</li> <li>&#x2026; hacia un objeto <b>destinatario</b></li> <li>Codifican qué <b>funcionalidad de la API</b> se precisa</li> </ul> </section> <section id="slide-modelado-orientado-a-objetos"> <h3 id="modelado-orientado-a-objetos"><span class="section-number-3">2.3.</span> Modelado orientado a objetos</h3> <p> La definición de objetos y las interacciones entre los mismos modelan el problema </p> </section> <section> <p> Vamos a modelar informalmente el video juego <a href="https://en.wikipedia.org/wiki/Space_Invaders">Space Invaders</a> </p> </section> <section> <p> aprecian naves enemigas, la nave amiga, marcadores de vidas y puntuación, proyectiles amigos y enemigos y las defensas de la nave <img src="/space-invaders.7c040fbe.jpg" alt="space-invaders.jpg"> </p> </section> <section id="slide-identificando-objetos"> <h3 id="identificando-objetos"><span class="section-number-3">2.4.</span> Identificando objetos</h3> <p> Una técnica para identificar objetos es pensar en <b>poner nombres</b> </p> <div id="org732f12d" class="figure"> <p><img src="/space-invaders-objects.fd9e0728.svg" alt="space-invaders-objects.svg" class="org-svg"> </p> <p><span class="figure-number">Figure 5: </span>Captura de Space Invaders donde se distinguen los objetos</p> </div> </section> <section> <p> Algunos objetos: nave amiga, enemigo 1, enemigo 2, enemigo 3, disparo amigo, disparo enemigo 1, disparo enemigo 2, defensa 1, defensa 2, marcador de vidas, marcador de puntuación </p> </section> <section id="slide-tipos-de-objetos-e-instancias"> <h3 id="tipos-de-objetos-e-instancias"><span class="section-number-3">2.5.</span> Tipos de objetos e instancias</h3> <p> Queda claro de un vistazo que muchos objetos concretos pertenecen a familias o <b>tipos</b> de objetos </p> <p> Conviene recordar que también se los llama <b>clases</b> </p> </section> <section> <p> Los tipos de objetos <b>especifican propiedades y comportamientos comunes</b> a todos ellos aunque individualmente sean distintos </p> </section> <section> <p> Algunos <b>tipos</b>: marcadores, defensas, nave amiga, enemigos, disparos </p> <p> tipos de objetos: marcadores, defensas, enemigos, protagonista y disparos <img src="/space-invaders-types.9b830e1c.svg" alt="space-invaders-types.svg" class="org-svg"> </p> </section> <section> <p> Los <b>valores</b> de un tipo son cada uno de los objetos individuales </p> <p> El enemigo especial, así como cada uno de los otros enemigos será un valor distinto del <b>tipo enemigo</b> </p> </section> <section> <p> Cuando utilizamos la terminología de clases, los valores se convierten en <b>instancias de la clase</b> </p> <p> En los modelos de objetos es más conveniente trabajar con tipos de objetos </p> </section> <section> <p> marcador, defensa, enemigo, protagonista y disparo <img src="/space-invaders-object-diagram.ba157bf6.svg" alt="space-invaders-object-diagram.svg" class="org-svg"> </p> </section> <section id="slide-interfaces-api-y-métodos"> <h3 id="interfaces-api-y-métodos"><span class="section-number-3">2.6.</span> Interfaces (API) y métodos</h3> <p> Vamos a tratar de determinar la API de nuestros tipos de objetos. Para eso nos guiarán las interacciones propias del juego </p> <div class="html" id="orgac3e26e"> <p> &lt;iframe width="560" height="315" src="<a href="https://www.youtube-nocookie.com/embed/UZlEXl9xgR8">https://www.youtube-nocookie.com/embed/UZlEXl9xgR8</a>" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt; </p> </div> <div class="html" id="org4e9ba24"> <p> &lt;/iframe&gt; </p> </div> </section> <section> <p> Un ejemplo: <i>los enemigos se mueven todos juntos hacia un lado, avanzan una línea y se mueven hacia el otro lado mientras disparan aleatoriamente</i> </p> <p> Vamos a <b>buscar verbos</b> esta vez: <b>mover</b>, <b>avanzar</b> y <b>disparar</b> </p> </section> <section> <p> Para poder implementar el comportamiento de los enemigos, estos tienen que poder moverse hacia los lados, avanzar y disparar </p> <p> Así, tendrán que permitir que les envíen mensajes pidiendo una de estas operaciones </p> </section> <section> <p> A las cosas que puede hacer un objeto se las denomina <b>métodos</b> </p> <p> izquierda, moverse a la derecha, avanzar y disparar. <img src="/space-invaders-enemy-api.118cb33c.svg" alt="space-invaders-enemy-api.svg" class="org-svg"> </p> </section> <section id="slide-estado-y-atributos"> <h3 id="estado-y-atributos"><span class="section-number-3">2.7.</span> Estado y atributos</h3> <p> Los objetos no sólo pueden hacer cosas sino que además capturan características de las entidades a las que representan </p> </section> <section> <p> Cada enemigo, por ejemplo, tiene un <b>gráfico distinto</b>, una <b>puntuación diferente</b>, una <b>posición en pantalla</b> y además recordará en qué <b>dirección se estaba moviendo</b> </p> </section> <section> <p> El estado no se suele exponer de forma directa en la API </p> <p> Piensa en el caso de los enemigos: incluso si estos tienen una posición, es preferible tener métodos específicos con los que manipular la posición (como "mover a la izquierda" o "mover a la derecha") en lugar de dar libre acceso a la posición </p> </section> <section> <p> A las características de un objeto se las denomina <b>atributos</b> </p> <p> posición y puntuación. <img src="/space-invaders-enemy-state.9ab13e2f.svg" alt="space-invaders-enemy-state.svg" class="org-svg"> </p> </section> <section id="slide-el-proceso-de-modelado-es-iterativo"> <h3 id="el-proceso-de-modelado-es-iterativo"><span class="section-number-3">2.8.</span> El proceso de modelado es iterativo</h3> <p> Al definir algunas acciones, hemos introducido nuevos nombres como <b>posición</b> o <b>dirección</b> que se convertirán en tipos de objetos con sus propios constructores </p> </section> <section id="slide-constructores-y-creación-de-objetos"> <h3 id="constructores-y-creación-de-objetos"><span class="section-number-3">2.9.</span> Constructores y creación de objetos</h3> <p> Pensemos en la interacción de disparo: <i>cuando el jugador pulsa el botón de disparo, aparece un proyectil delante de la nave amiga que avanza hasta alcanzar la parte superior de la pantalla o colisionar con un enemigo</i> </p> <p> El proyectil no estaba ahí antes y tendrá que ser creado en el momento del disparo </p> </section> <section> <p> Otro ejemplo, la preparación del nivel antes de jugar: <i>aparecen 55 enemigos en pantalla, 5 filas de 11 enemigos con la siguiente configuración: 1 fila de enemigos de la especie 1, dos filas de la especie 2, 1 de la especie 3 y 1 de la especie 4</i> </p> </section> <section> <p> Está claro que no queremos escribir los 55 enemigos individualmente </p> <p> Además, dado que todos pertenecen al tipo enemigo, queda claro que serán todos muy parecidos </p> </section> <section> <p> Lo que necesitamos es un mecanismo de <b>generación automática de objetos</b> </p> <p> Cada lenguaje ofrece formas distintas de crear objetos </p> </section> <section> <p> Nosotros vamos a añadir un nuevo objeto, el <b>contructor</b>, cuya tarea es la de generar objetos de un tipo dado </p> <p> Así, encontraremos <b>un contructor por tipo</b> </p> </section> <section> <p> posición y puntuación <img src="/space-invaders-constructors.14047469.svg" alt="space-invaders-constructors.svg" class="org-svg"> </p> </section> <section> <p> Los constructores tienen una API muy sencilla: <b>nuevo objeto</b> </p> <p> Este método crea un nuevo objeto de un tipo dado </p> </section> <section> <p> nuevo objeto. <img src="/space-invaders-constructor-detail.e3becd03.svg" alt="space-invaders-constructor-detail.svg" class="org-svg"> </p> </section> <section> <p> Los constructores suelen permitir personalizar partes del objeto que están creando de forma que se le pueda decir algo como "crea un disparo con esta posición, este gráfico y esta dirección de avance" </p> </section> <section> <p> nuevo objeto <img src="/space-invaders-constructor-example.17570c49.svg" alt="space-invaders-constructor-example.svg" class="org-svg"> </p> </section> <section id="slide-relaciones-entre-tipos"> <h3 id="relaciones-entre-tipos"><span class="section-number-3">2.10.</span> Relaciones entre tipos</h3> <p> Cuando modelamos, surgen relaciones de forma natural </p> <p> Los enemigos <b>tienen</b> una posición </p> <p> La nave amiga <b>crea</b> disparos </p> </section> <section> <p> Nuestro cerebro tiende a establecer jerarquías entre objetos creando tipos más generalistas </p> <p> Por ejemplo: en vez de pensar en enemigos y protagonista por separado, es posible pensar en <b>naves</b> </p> </section> <section> <p> El <b>tipo nave</b> reúne los métodos y atributos comunes de la nave protagonista y enemigos </p> </section> <section> <p> super-tipo nave <img src="/space-invaders-hierarchy.a7fa25bd.svg" alt="space-invaders-hierarchy.svg" class="org-svg"> </p> </section> <section> <p> Esta jerarquía establece <b>relaciones de herencia</b> también llamadas relaciones "<b>es un(a)</b>" dado que <b>el protagonista es una nave</b> y <b>el enemigo es una nave</b> </p> </section> <section> <p> Se dice que <b>el tipo enemigo extiende al tipo nave</b> añadiendo avanzar a la API, y la puntuación y la última dirección de desplazamiento al estado </p> </section> <section> <p> La nave amiga no añade ningún método nuevo pero <b>redefine o sobreescribe</b> el método disparar para que dispare hacia arriba </p> </section> <section> <p> Como hay nuevos tipos, tendremos nuevos constructores </p> <p> Los viejos constructores pueden delegar parte de la creación del objeto (las partes comunes) a los nuevos </p> </section> <section> <p> pide al constructor de naves una nave, la personaliza para que sea un enemigo y devuelve el enemigo <img src="/space-invaders-hierarchy-constructor.b82a745b.svg" alt="space-invaders-hierarchy-constructor.svg" class="org-svg"> </p> </section> <section> <p> De esta forma al pedir un enemigo, el constructor de enemigos pedirá una nave al constructor de naves </p> <p> Tomará esa nave, la modificará para que sea un enemigo y devolverá un enemigo </p> </section> <section> <blockquote> <p> OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things </p> </blockquote> <p> <a href="http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">Alan Kays sobre la programación orientada a objetos</a> </p> </section> </section> </div> </div> <script src="/tooling.reveal.62c78f3a.js"></script> <script src="/tooling.reveal.f05d24be.js"></script> <script src="/tooling.reveal.f6a6f820.js"></script> <script src="/tooling.reveal.d2982244.js"></script> <script>Reveal.initialize({controls:!0,progress:!0,history:!1,center:!0,slideNumber:"c",rollingLinks:!1,keyboard:!0,mouseWheel:!1,fragmentInURL:!1,hashOneBasedIndex:!1,pdfSeparateFragments:!0,overview:!0,transition:"convex",transitionSpeed:"default",plugins:[RevealSearch,RevealHighlight,RevealZoom],dependencies:[]});</script> </body></html>