<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="author" content="Carlos León"><style>.underline{text-decoration:underline}</style><link rel="stylesheet" href="tooling.reveal.e38fa0d8.css"><link rel="stylesheet" href="tooling.reveal.a866bf8d.css" id="theme"><link rel="stylesheet" href="tooling.reveal.fdb16a0d.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body> <div class="reveal"> <div class="slides"> <section id="sec-title-slide"> <h2 class="author">Carlos León</h2><p class="date">Created: 2024-01-30 mar 13:32</p> </section> <section> <section id="slide-contexto"> <h2 id="contexto"><span class="section-number-2">1.</span> Contexto</h2> </section> <section> </section> <section id="slide-gamejam-2020"> <h3 id="gamejam-2020"><span class="section-number-3">1.1.</span> GameJam 2020</h3> <p> Del 31 de enero al 2 de febrero de 2020, UCM es sede GameJam 2020 en Madrid </p> </section> <section> </section> <section id="slide-medialab-prado"> <h3 id="medialab-prado"><span class="section-number-3">1.2.</span> Medialab Prado</h3> <p> La GGJ UCM se organizó en Medialab Prado </p> <p> <a href="https://www.medialab-prado.es">https://www.medialab-prado.es</a> </p> </section> <section> </section> <section id="slide-pantalla"> <h3 id="pantalla"><span class="section-number-3">1.3.</span> Pantalla</h3> <p> Medialab Prado tiene una pantalla en la fachada exterior que se puede usar </p> <p> <a href="https://www.medialab-prado.es/noticias/fachada-digital-informacion-tecnica-0">https://www.medialab-prado.es/noticias/fachada-digital-informacion-tecnica-0</a> </p> </section> <section> </section> <section id="slide-dimensiones"> <h3 id="dimensiones"><span class="section-number-3">1.4.</span> Dimensiones</h3> <ul> <li>15m \(\times\) 10m</li> <li>192 \(\times\) 157 "píxeles" (enormes)</li> </ul> </section> <section> <div id="org2918be2" class="figure"> <p><img src="https://www.medialab-prado.es/sites/default/files/import/ftp_medialab/5/5770/500_0.png" alt="500_0.png"> </p> <p><span class="figure-number">Figure 1: </span>Diagrama de la pantalla</p> </div> </section> <section> <p> La pantalla sólo se ve bien de noche (está habilitada como de 18:30 a 23:30) </p> </section> <section> <p> El tamaño de la plaza hace que se vea muy cerca, con lo que los píxeles inferiores se ven <i>bastante mayores</i> que los superiores </p> </section> <section> </section> <section id="slide-sonido"> <h3 id="sonido"><span class="section-number-3">1.5.</span> Sonido</h3> <p> No hay sonido (está en medio de la calle) </p> </section> <section> </section> <section id="slide-cámaras"> <h3 id="cámaras"><span class="section-number-3">1.6.</span> Cámaras</h3> <p> Hay un sistema CCTV que recoge la interacción de la gente en la plaza </p> <p> <i>Y un API de alto nivel de reconocimiento de personas</i> </p> </section> </section> <section> <section id="slide-programando-la-fachada"> <h2 id="programando-la-fachada"><span class="section-number-2">2.</span> Programando la fachada</h2> </section> <section> <p> Tienen un PC con salida directa a la fachada, con lo que cualquier trozo imagen que quepa en 192 \(\times\) 157, se puede emitir </p> </section> <section> <p> Esto requiere bastante gestión (aunque es posible) </p> </section> <section> </section> <section id="slide-processing"> <h3 id="processing"><span class="section-number-3">2.1.</span> Processing</h3> <p> Medialab Prado ofrece un API de alto nivel para programar la fachada y la cámara </p> <p> Está basado en <a href="https://processing.org">Processing</a> </p> </section> <section> <div class="org-src-container"> <pre><code class="java">int y = 100;

void setup() {
  size(640, 360); 
  stroke(255); 
  frameRate(30);
}
void draw() { 
  background(0); 
  y = y - 1; 
  if (y &lt; 0) { 
    y = height; 
  } 
  line(0, y, width, y);  
} 
</code></pre> </div> <p> <a href="https://processing.org/examples/setupdraw.html">Enlace al ejemplo</a> </p> </section> </section> <section> <section id="slide-p5.js-y-javascript"> <h2 id="p5.js-y-javascript"><span class="section-number-2">3.</span> P5.js y JavaScript</h2> </section> <section> <p> Dado que <i>Programa la plaza</i> ofrece una plataforma web, se recomienda usar <a href="https://p5js.org">P5.js</a>, que es <i>Processing</i>, pero con JavaScript </p> </section> <section> <div class="org-src-container"> <pre><code class="js">let y = 100;

function setup() {
  createCanvas(720, 400);
  stroke(255); 
  frameRate(30);
}
function draw() {
  background(0);
  y = y - 1;
  if (y &lt; 0) {
    y = height;
  }
  line(0, y, width, y);
}
</code></pre> </div> <p> <a href="https://p5js.org/examples/structure-setup-and-draw.html">Enlace al ejemplo</a> </p> </section> <section> <p> Hacer con JavaScript y P5.js es mucho más flexible (y está más mantenido) </p> </section> </section> <section> <section id="slide-plataforma-programa-la-plaza"> <h2 id="plataforma-programa-la-plaza"><span class="section-number-2">4.</span> Plataforma "Programa la plaza"</h2> </section> <section> <p> Desde <a href="http://programalaplaza.medialab-prado.es">http://programalaplaza.medialab-prado.es</a> se puede crear una cuenta y empezar a programar directamente en el navegador </p> </section> <section> <p> La plataforma no solo ofrece un editor, también ofrece un API </p> </section> <section> </section> <section id="slide-api-seguimiento-de-personas-tracking"> <h3 id="api-seguimiento-de-personas-tracking"><span class="section-number-3">4.1.</span> API seguimiento de personas (<i>tracking</i>)</h3> <div class="org-src-container"> <pre><code class="js">function setup() {
  api.tracking.connect();
}

function draw() {
  var blobs = api.tracking.getBlobs();
    for (var i = 0; i &lt; blobs.length; i++) {
  }
}
</code></pre> </div> </section> <section> </section> <section id="slide-api-de-guardado"> <h3 id="api-de-guardado"><span class="section-number-3">4.2.</span> API de guardado</h3> <p> Datos que se almacenan durante el tiempo de muestra </p> <div class="org-src-container"> <pre><code class="js">api.storage.set('valor', 15);
// ...
valor = api.storage.get('valor');
</code></pre> </div> </section> <section> </section> <section id="slide-imágenes"> <h3 id="imágenes"><span class="section-number-3">4.3.</span> Imágenes</h3> <p> Para usar imágenes (cualquier tipo soportado por P5.js), se suben a la plataforma y luego se referencian por la URL que nos da el sistema </p> </section> <section> <div id="org5f30570" class="figure"> <p><img src="subirimagen.e156feda.png" alt="subirimagen.png"> </p> <p><span class="figure-number">Figure 2: </span>Subir imágenes</p> </div> </section> </section> <section> <section id="slide-proxy"> <h2 id="proxy"><span class="section-number-2">5.</span> Proxy</h2> </section> <section> <p> "Programa la Plaza" tiene un <i>API</i> para el reconocimiento de personas: </p> <div class="org-src-container"> <pre><code class="js">api.tracking.connect()
api.tracking.getBlobs()
</code></pre> </div> <p> <i>Pero no podemos usarlo mientras desarrollamos</i> </p> </section> <section> <p> Para el desarrollo se creó un <i>proxy</i> del API que usa el ratón como sustituto de la cámara </p> </section> <section> <p> Se crea un <i>array</i> (<code>api.tracking.blobs</code>) y, cada vez que se arrastra por pantalla (que simula a la cámara), metemos más elementos en el array </p> <p> Este <i>array</i> simula los "blobs" que nos ofrece el <i>API</i> </p> </section> <section> <p> Usamos <code>mouseDragged()</code> P5.js para recibir la entrada de ratón y cambiar al <i>array</i>: </p> <div class="org-src-container"> <pre><code class="js">function mouseDragged() {
  if (overBox &gt; released) {
    const found = api.tracking.blobs.find(blob =&gt;
      blob.id === overBox)
    if (found) {
      found.x = mouseX
      found.y = mouseY
    }
  }
}
</code></pre> </div> </section> <section> <p> Después, exportamos nuestro propio objeto <code>api</code> </p> <div class="org-src-container"> <pre><code class="js">const api = {
  // ...
  tracking: {
    connect: function () { },
    getBlobs: function () {
      return JSON.parse(JSON.stringify(api.tracking.blobs))
    },
    blobs: []
  }
}
</code></pre> </div> </section> <section> <p> Como hemos llamado igual a nuestro <i>API</i>, sólo tenemos que subir el código (sin nuestro <i>API</i> proxy), y funcionará </p> </section> </section> <section> <section id="slide-el-juego"> <h2 id="el-juego"><span class="section-number-2">6.</span> El juego</h2> </section> <section> <div id="org79418ba" class="figure"> <p><img src="juego.a4a3d3ac.gif" alt="juego.gif"> </p> <p><span class="figure-number">Figure 3: </span>El juego</p> </div> </section> <section> <p> En el juego, los jugadores sólo se mueven por la plaza (es la única entrada) </p> <p> La cámara los reconoce, y nos ofrece posiciones de cada jugador \((x, y)\), a esto le llama <i>blob</i> </p> </section> <section> <p> Cuando un <i>blob</i> cambia, primero vemos si es alguno que ya estaba o es nuevo (porque la <i>API</i> sólo nos dice el <code>id</code> del <i>blob</i>) </p> <p> Se probó con <code>id</code> y con <code>posicion</code>, y por <code>id</code> funcionaba mejor </p> </section> <section> <p> Con la posición, generamos enemigos (fantasmas), puertas y palancas </p> <p> Las puertas se abren según el tipo de habitación: </p> <ul> <li>Solas (están abiertas)</li> <li>Cuando se derrota a todos los enemigos</li> <li>Cuando se activa una palanca</li> </ul> </section> <section> <p> Hay 2 tipos de personajes: </p> <ul> <li>Guerreros (atacan "cuerpo a cuerpo")</li> <li>Magos (disparan bolas de fuego)</li> </ul> <p> Como no hay más entrada que la posición, disparan solos cada cierto tiempo </p> </section> <section> <p> Los personajes no mueren, no hay desafío real </p> <p> Pero no es necesario, ya que la gente juega porque está en la calle, y por el avance en el juego </p> </section> <section id="slide-generación-de-habitaciones"> <h3 id="generación-de-habitaciones"><span class="section-number-3">6.1.</span> Generación de habitaciones</h3> <p> La generación de habitaciones es aleatoria </p> <p> Para no tener que llevar el control del mapa, evitamos que se vuelva a atrás, <i>no hay puertas ni hacia abajo ni por donde hemos venido</i> </p> </section> <section id="slide-el-dragón"> <h3 id="el-dragón"><span class="section-number-3">6.2.</span> El dragón</h3> <p> A partir de cierto número de habitaciones, hay probabilidad de que aparezca el dragón </p> <p> Cuando el dragón muere (necesita varios golpes) </p> </section> <section id="slide-desafíos-de-programación"> <h3 id="desafíos-de-programación"><span class="section-number-3">6.3.</span> Desafíos de programación</h3> <p> El juego se hizo en P5.js, que es mucho menos potente que Phaser </p> </section> <section id="slide-animaciones"> <h4 id="animaciones"><span class="section-number-4">6.3.1.</span> Animaciones</h4> <div class="org-src-container"> <pre><code class="js">actualizar() {
  super.actualizar()

  this.tiempoAnimacion += delta()
  if (this.tiempoAnimacion &gt;= this.animacion.periodo) {
    this.tiempoAnimacion = 0
    const l = this.animacion.fotogramas.length

    if (this.fotograma === l - 1) {
      if (this.animacion.terminada &amp;&amp; !this.terminadaLlamada) {
        this.animacion.terminada(this)
        this.terminadaLlamada = true
      }
      if (this.animacion.vuelta) {
        this.establecerFotograma()
      }
    } else {
      this.establecerFotograma(this.fotograma + 1)
    }
  }
}
</code></pre> </div> </section> <section id="slide-colisiones"> <h4 id="colisiones"><span class="section-number-4">6.3.2.</span> Colisiones</h4> <div class="org-src-container"> <pre><code class="js">// `input` puede ser un objeto, o la `x`
solapa(input, y = undefined, w = undefined, h = undefined) {
  const other = typeof input === 'number' ? { x: input, y, w, h } : input
  return this.x &lt; other.x + other.w &amp;&amp;
    this.x + this.w &gt; other.x &amp;&amp;
    this.y &lt; other.y + other.h &amp;&amp;
    this.h + this.y &gt; other.y
}
</code></pre> </div> </section> <section id="slide-movimiento-a-un-punto"> <h4 id="movimiento-a-un-punto"><span class="section-number-4">6.3.3.</span> Movimiento a un punto</h4> <div class="org-src-container"> <pre><code class="js">actualizar() {
  super.actualizar()
  if (this.vivo) {
    if (dist(this.x, this.y, this.destino.x, this.destino.y) &lt; Fantasma.tamano) {
      this.nuevoDestino()
    }
    const v = Fantasma.velocidad / delta()
    const angulo = atan2(this.destino.y - this.y, this.destino.x - this.x)
    this.x += v * cos(angulo)
    this.y += v * sin(angulo)
  }
}
</code></pre> </div> </section> </section> <section> <section id="slide-arte"> <h2 id="arte"><span class="section-number-2">7.</span> Arte</h2> </section> <section> <p> Todo el juego se dibujó con arte píxel porque la pantalla tiene muy pocos puntos, y muy grandes </p> <p> Se animó frame a frame </p> </section> <section> <p> El arte es original, pero basado en buena medida en otros recursos encontrados en Internet </p> <p> Algunas imágenes se calcaron con cierta libertad y luego se pasaron a arte píxel </p> </section> <section> <p> ¡Gracias al prof. Guillermo Jiménez por los logos de la UCM y la Game Jam! </p> </section> <section> <div id="org2717c57" class="figure"> <p><img src="ggj_ucm.32c8c3f8.png" alt="ggj_ucm.png"> </p> <p><span class="figure-number">Figure 4: </span>Logo UCM</p> </div> </section> <section> <div id="org1b7c30f" class="figure"> <p><img src="ggj_dragon.de31d171.png" alt="ggj_dragon.png"> </p> <p><span class="figure-number">Figure 5: </span>Dragón</p> </div> </section> <section> <div id="org1a7717b" class="figure"> <p><img src="ggj_ggj.564d7699.png" alt="ggj_ggj.png"> </p> <p><span class="figure-number">Figure 6: </span>Logo GGJ</p> </div> </section> <section> <div id="orgf0ca861" class="figure"> <p><img src="ggj_guerrero.886f8d83.png" alt="ggj_guerrero.png"> </p> <p><span class="figure-number">Figure 7: </span>Guerrero</p> </div> </section> <section> <div id="org43bb72f" class="figure"> <p><img src="ggj_magia.790a53ca.png" alt="ggj_magia.png"> </p> <p><span class="figure-number">Figure 8: </span>Magia</p> </div> </section> <section> <div id="org75bb1b7" class="figure"> <p><img src="ggj_mago.1b3fb10f.png" alt="ggj_mago.png"> </p> <p><span class="figure-number">Figure 9: </span>Mago</p> </div> </section> <section> <div id="orgabac4fc" class="figure"> <p><img src="ggj_palanca.fc08142c.png" alt="ggj_palanca.png"> </p> <p><span class="figure-number">Figure 10: </span>Palanca</p> </div> </section> <section> <div id="org9c76896" class="figure"> <p><img src="ggj_puerta.68131bdd.png" alt="ggj_puerta.png"> </p> <p><span class="figure-number">Figure 11: </span>Puerta</p> </div> </section> <section> <p> jugador <img src="fantasma.702e8be7.gif" alt="fantasma.gif"> </p> </section> </section> <section> <section id="slide-el-juego-1"> <h2 id="el-juego-1"><span class="section-number-2">8.</span> El juego</h2> </section> <section> <p> Todo está <a href="https://github.com/cleongh/majemag">accesible en GitHub</a> </p> </section> <section> <div id="org327048f" class="figure"> <p><img src="pantalla_mlp.ed1ff263.jpg" alt="pantalla_mlp.jpg"> </p> <p><span class="figure-number">Figure 12: </span>Pantalla MLP con el juego</p> </div> </section> </section> </div> </div> <script src="tooling.reveal.ffb33b1a.js"></script> <script src="tooling.reveal.f05d24be.js"></script> <script src="tooling.reveal.1feea775.js"></script> <script src="tooling.reveal.d2982244.js"></script> <script>Reveal.initialize({controls:!0,progress:!0,history:!1,center:!0,slideNumber:"c",rollingLinks:!1,keyboard:!0,mouseWheel:!1,fragmentInURL:!1,hashOneBasedIndex:!1,pdfSeparateFragments:!0,overview:!0,transition:"convex",transitionSpeed:"default",plugins:[RevealSearch,RevealHighlight,RevealZoom],dependencies:[]});</script> </body></html>